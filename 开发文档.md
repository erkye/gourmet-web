# 菜谱分享小程序开发文档

## 项目概览

项目分为前端（微信小程序端）和后端项目，前端项目名称为 [gourmet-web](https://gitee.com/lifazhan/gourmet-web)，后端项目名称为 [gourmet-api](https://gitee.com/lifazhan/gourmet-api)。

项目结构为前后端分离结构，前后端使用json格式进行交互。

数据库使用MySQL 8.0。

### 微信小程序端（仅列举，自行百度瞎吹）

* 微信小程序端使用原生开发框架
* 使用webpack管理项目
* 使用npm管理项目依赖
* 项目开发的所有图标资源均使用[阿里巴巴矢量图库](https://www.iconfont.cn/)
* 使用axios发起服务端请求
* 调试基本库选择2.13.1
* 使用git进行版本控制

### 服务端（不是重点，放上凑字数）

* 使用Java开发，框架使用Spring Boot + MyBatis

### 数据库

使用MySQL 8.0

**表概览**（6）

* 菜谱主表
* 用料表
* 菜谱浏览记录表
* 分类表（两级或三级分类）
* 用户表
* 用户收藏表

**表详细**

* 菜谱主表（gourmet_menu）

  | 字段名    | 类型    | 备注                     |
  | --------- | ------- | ------------------------ |
  | id        | int     | 主键，自增               |
  | img       | varchar | 菜谱图片url              |
  | title     | varchar | 菜谱标题                 |
  | introd    | varchar | 菜谱简介                 |
  | content   | text    | 菜谱内容（html）         |
  | nickname  | varchar | 作者昵称                 |
  | recommend | tinyint | 是否是推荐（首页轮播图） |

* 用料表（gourmet_materials）

  | 字段名   | 类型    | 备注                 |
  | -------- | ------- | -------------------- |
  | id       | int     | 主键，自增           |
  | menu_id  | int     | 外键（菜谱主表的id） |
  | name     | varchar | 材料名称             |
  | quantity | varchar | 用量                 |

* 菜谱浏览记录表（gourmet_menu_scan）

  | 字段名    | 类型 | 备注                 |
  | --------- | ---- | -------------------- |
  | id        | int  | 主键，自增           |
  | menu_id   | int  | 外键（菜谱主表的id） |
  | pageviews | int  | 浏览量               |
  | favorites | int  | 收藏量               |

* 分类表（gourmet_classify）

  | 字段名    | 类型    | 备注       |
  | --------- | ------- | ---------- |
  | id        | int     | 主键，自增 |
  | name      | varchar | 分类名称   |
  | parent_id | int     | 父级分类id |

* 用户表（gourmet_user）

  | 字段名    | 类型    | 备注       |
  | --------- | ------- | ---------- |
  | id        | int     | 主键，自增 |
  | nick_name | varchar | 用户昵称   |

* 用户收藏表（gourmet_star）（**这个表写着写着发现好像没啥用...**）

  | 字段名  | 类型 | 备注                         |
  | ------- | ---- | ---------------------------- |
  | user_id | int  | 双主键，用户表外键，用户表id |
  | menu_id | int  | 双主键，菜谱表外键，菜谱表id |

### 数据库创建

**数据库和服务端项目均部署到服务器上，下面这些只是用来写文档的，无需创建数据库！！！**

![image-20201008191326317](https://gitee.com//lifazhan/mypics/raw/master/img/20201008191335.png)

**数据库名称：gourmet**

**字符集：utf8mb4**

**排序规则：utf8mb4_general_ci**



**数据库创建SQL语句**

* ​	用户表 gourmet_user

  ```sql
  CREATE TABLE `gourmet_user` (
    `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
    `nick_name` varchar(255) COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户昵称',
    PRIMARY KEY (`id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
  ```

* 菜谱表 gourmet_menu

  ```sql
  CREATE TABLE `gourmet_menu` (
    `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
    `img` varchar(255) COLLATE utf8mb4_general_ci NOT NULL COMMENT '菜谱图片url',
    `title` varchar(255) COLLATE utf8mb4_general_ci NOT NULL COMMENT '菜谱标题',
    `introd` varchar(255) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '菜谱简介',
    `content` text COLLATE utf8mb4_general_ci NOT NULL COMMENT '菜谱内容（html）',
    `nickname` varchar(255) COLLATE utf8mb4_general_ci NOT NULL COMMENT '作者昵称',
    `recommend` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '是否是推荐（首页轮播图）',
    PRIMARY KEY (`id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
  ```

* 分类表 gourmet_classify

  ```sql
  CREATE TABLE `gourmet_classify` (
    `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
    `name` varchar(255) COLLATE utf8mb4_general_ci NOT NULL COMMENT '分类名称',
    `parent_id` int(10) unsigned DEFAULT '0' COMMENT '父级分类id',
    PRIMARY KEY (`id`),
    KEY `fore_parentid` (`parent_id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=41 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
  ```

* 材料表 gourmet_materials

  ```sql
  CREATE TABLE `gourmet_materials` (
    `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
    `menu_id` int(11) unsigned NOT NULL COMMENT '外键（菜谱主表的id）',
    `name` varchar(255) COLLATE utf8mb4_general_ci NOT NULL COMMENT '材料名称',
    `quantity` varchar(255) COLLATE utf8mb4_general_ci NOT NULL COMMENT '用量',
    PRIMARY KEY (`id`),
    KEY `fk_menu_materials` (`menu_id`),
    CONSTRAINT `fk_menu_materials` FOREIGN KEY (`menu_id`) REFERENCES `gourmet_menu` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
  ) ENGINE=InnoDB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
  ```

* 菜谱浏览记录表 gourmet_menu_scan

  ```sql
  CREATE TABLE `gourmet_menu_scan` (
    `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键，自增',
    `menu_id` int(10) unsigned NOT NULL COMMENT '外键（菜谱主表的id）',
    `pageviews` bigint(20) unsigned NOT NULL DEFAULT '0' COMMENT '浏览量',
    `favorites` bigint(20) unsigned NOT NULL DEFAULT '0' COMMENT '收藏量',
    PRIMARY KEY (`id`),
    KEY `fk_menu_scan` (`menu_id`),
    CONSTRAINT `fk_menu_scan` FOREIGN KEY (`menu_id`) REFERENCES `gourmet_menu` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
  ) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
  ```

## 前后端交互

#### 统一使用axios

**使用方式：**

**下面也是写报告用的，无需执行**

* 使用npm安装，目录下要有package.json，没有的话执行下面命令

  ```
  npm init
  ```

* 安装axios

  ```
  npm i axios axios-miniprogram-adapter
  ```

* 微信开发者工具点击：工具--构建npm，项目中出现miniprogram_npm文件夹表示构建成功！！

#### 写为工具类

使用axios可以极大的简化后端发起请求的方式，一般情况下服务器的请求地址有一部分时重复的（ip地址端口），如果每个页面都去创建axios对象，设置请求地址的话开发效率非常低下，因此项目中将axios封装到工具类中，需要发起请求的页面仅需要引入工具类即可！

在**resquest**目录下创建了一个**http.js** 文件，抽离出创建axios实例的方法，使用页面直接引用此文件即可使用axios

```js
import axios from 'axios'
import mpAdapter from 'axios-miniprogram-adapter'
axios.defaults.adapter = mpAdapter

// 服务器的地址 这部分请求地址都是一样的 所以提取出来
const serverIp = "http://150.158.174.106:3000/api"
// 构建axios实例
const http = axios.create({
  // 设置axios对象的基本请求地址
  baseURL: serverIp

})

// 导出实例
module.exports = {http,serverIp} 
```

**注意：小程序调试基本库需要设置为较新的版本（此处设置为 2.13.1）**

使用：

```js
// 导入刚才的工具类
import {http} from '../../resquent/http'
```

请求示例：

```js
// 获取滑动视图的数据
// async 凡是方法内有await的，方法必须声明为async 表示这是一个含有同步代码的方法
  async getSwipperData(){
    // await 因为请求都是需要时间的，而js又是异步的，也就是说下面两行代码不一行谁先执行，为了保证response已经获取到
    //  使用await修饰可以保证下面的代码必须等待执行完获到数据才能使用
    const {data:response} = await http.get('/menu/recommend')
    console.log(response)
  }
```

此处使用了 ES7 的 async/await 语法来获取异步请求的数据，小程序较新的调试基本库支持 ES7（ES7 转 ES5） 语法，{data:response} 作用是将响应数据对象中data属性映射为response

**理解**

* async 这个方法被同步了

* await 必须等我执行完

* {data:response} 返回的对象里有一个叫data的属性，我用个response接收一下 等同于下面代码

  ```js
  const res = await http.get('/menu/recommend')
  const response = res.data
  ```

  

## 资源

#### 图标资源

![image-20201028194735441](https://gitee.com//lifazhan/mypics/raw/master/img/20201028194742.png)

**使用**

* 官网挑选完图标后生成css代码，粘贴下面文件中

![image-20201012205050567](https://gitee.com//lifazhan/mypics/raw/master/img/20201012205050.png)

* 需要使用的页面在其css文件中引入

![image-20201012205129021](https://gitee.com//lifazhan/mypics/raw/master/img/20201012205129.png)

* 在html中使用text标签或者view标签，class写为“iconfont icon-user”即可，其中iconfont 必须有，icon-user对应要使用图标

![image-20201012205213405](https://gitee.com//lifazhan/mypics/raw/master/img/20201012205213.png)

* 效果

![image-20201028195230705](https://gitee.com//lifazhan/mypics/raw/master/img/20201028195230.png)

## 分页面介绍（重点）

### 首页

#### 布局

![image-20201028202343282](https://gitee.com//lifazhan/mypics/raw/master/img/20201028202343.png)

首页主要分为四个区域，分别为搜索栏，推荐视图区域、常用分类区域，最新佳作列表区域。

#### 分区域介绍

##### 搜索栏

搜索栏在首页和分类页面都有，因此将搜索栏提取出来为一个组件。位于components/serchInput 目录下

![image-20201028202729560](https://gitee.com//lifazhan/mypics/raw/master/img/20201028202729.png)

**searchInput.json配置文件**

```json
{
  "component": true,
  "usingComponents": {}
}
```

"component": true 表示当前页面文件时一个组件，而不是普通的微信小程序页面

*"usingComponents"*: {} 如果使用其他组件在{}中引入



**searchInput.wxml 页面文件**

```html
<!--搜索框-->
<view class="search-view">
  <navigator class="search-input" url="/pages/search/search" hover-class="navigator-hover" open-type="navigate">
    🔍 搜索
  </navigator>
</view>

```

此处的搜索栏并非是一个真正的输入框，而是用了一个navigator标签代替，通过css样式改成搜索框的模样，点击时会跳转到真正的搜索页

**searchInput.wxss 样式文件**

```css
/**包裹搜索框的样式**/
.search-view{
  /**搜索框文字居中**/
  text-align: center;
  /**搜索框外部颜色**/
  background-color: #ea5455;
  /**调整整个搜索框居中**/
  display: flex;
  justify-content: center;
}
/**搜索框的样式**/
.search-input{
  /* 调整输入框的内的字体水平和垂直居中 */
  display: flex;
  justify-content: center;
  align-items: center;
  /**设置宽高**/
  height: 35px; 
  width: 680rpx;
  /**背景颜色**/
  background-color: #fff;
  /**边框样式**/
  border: 1px solid lightgray;
  /**边框圆角**/
  border-radius: 8px;
  /**上下边距**/
  margin-top: 10px;
  margin-bottom: 10px;
  font-size: medium;
}
```

**searchInput.js 逻辑文件**

其实没啥逻辑😂~~

```js
// components/searchInput/searchInput.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {

  },

  /**
   * 组件的初始数据
   */
  data: {

  },

  /**
   * 组件的方法列表
   */
  methods: {

  }
})
```

回到首页的配置文件中

**index.json 首页配置文件**

```json
{
  "usingComponents": { "searchInput": "/components/searchInput/searchInput" }
}
```

"usingComponents": { "searchInput": "/components/searchInput/searchInput" } 引用刚才编写的搜索栏组件 此处的searchInput 和页面中使用标签名对应

**index.wxml 首页文件**

```html
 <!-- 输入框组件开始 使用components里面的输入框组件 -->
  <searchInput></searchInput>
```

搜索栏区域结束

##### 推荐视图区域

* 推荐视图区域使用的 [swiper](https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html) 滑块组件
* 滑块组件里面是每一个滑块项 [swiper-item](https://developers.weixin.qq.com/miniprogram/dev/component/swiper-item.html)，需要使用wx-for遍历显示
* 每个滑块项点击时要可以跳转到对应菜谱的页面，使用navigator
* 每个滑块项都是显示图片，使用image标签

因此index.wxml中的结构如下：

```html
<!-- 滑块视图组件 indicator-dots 显示小点点 autoplay 开启自动播放 circular 循环衔接滑动 -->
    <swiper class="swiper" indicator-dots autoplay circular>
      <!-- 遍历data中的视图url数组 普通字符数组 所以key值是本身 -->
      <block wx:for="{{swiperData}}" wx:key="item.id">
        <swiper-item>
          <navigator url="/pages/menucontent/menucontent?id={{item.id}}">
            <!-- 遍历显示图片 src属性：图片地址 mode属性：aspectFill缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。 -->
            <image class="swiper-img" src="{{item.img}}" mode="aspectFill"></image>
          </navigator>
        </swiper-item>
      </block>
    </swiper>
```

页面渲染需要数据，数据部分在index.js文件中

首先在data属性中定义数组

```js
data: {
    // 滑动视图的数据
    swiperData: []
  },
```

编写方法从后端获取数据

```js
 // 获取滑动视图的数据
  async getSwipperData() {
    // 从后端获取数据
    const { data: response } = await http.get("/index/recommend");
    //console.log(response)
    // 获取数据成功
    if (response.code === 1000) {
      // 设置滑动视图的数据
      this.setData({ swiperData: response.data });
    }
  },
```

数据返回格式如下：

```json
{
  "code": 1000,
  "msg": "操作成功",
  "data": [
    {
      "id": 2,
      "img": "https://images.pexels.com/photos/5419093/pexels-photo-5419093.jpeg?auto\u003dcompress\u0026cs\u003dtinysrgb\u0026dpr\u003d1\u0026w\u003d500",
      "title": "测试2",
      "introd": "这是测试2的简介",
      "nickname": "TEST",
      "recommend": true
    },
    {
      "id": 3,
      "img": "https://images.pexels.com/photos/3464543/pexels-photo-3464543.jpeg?auto\u003dcompress\u0026cs\u003dtinysrgb\u0026dpr\u003d1\u0026w\u003d500",
      "title": "测试3",
      "introd": "这是测试3的简介",
      "nickname": "TEST",
      "recommend": true
    }
  ]
}
```

在页面加载时就要获取该数据，在页面加载函数中调用

```js
 onLoad: function () {
    // 获取滑动视图的数据
    this.getSwipperData();
  },
```

样式文件 略



##### 常用分类区域



### 搜索页

### 分类页

### 菜谱详细内容页

### 发布/编辑页

### 个人中心页

### 登录授权页

### 我的发布页

### 我的收藏页

